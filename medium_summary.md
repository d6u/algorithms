# Medium Problem Summary

## String

- [022-generate-parenthesis.java](./leetcode-java/022-generate-parenthesis.java)

    Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

## DP

- [338-counting-bits.js](./leetcode-js/338-counting-bits.js)

    Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

- [256-paint-house.java](./leetcode-java/256-paint-house.java)

    There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

- [122-best-time-to-buy-and-sell-stock-ii.java](./leetcode-java/122-best-time-to-buy-and-sell-stock-ii.java)

    Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

- [357-count-numbers-with-unique-digits.java](./leetcode-java/357-count-numbers-with-unique-digits.java)

    Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10^n.

- [309-best-time-to-buy-and-sell-stock-with-cooldown.java](./leetcode-java/309-best-time-to-buy-and-sell-stock-with-cooldown.java)

    Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

    - You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
    - After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)

## Tree & Graph

- [366-find-leaves-of-binary-tree.js](./leetcode-js/366-find-leaves-of-binary-tree.js)

    Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.

- [261-graph-valid-tree_union-find.js](./leetcode-js/261-graph-valid-tree_union-find.js)

    Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

- [323-number-of-connected-components-in-an-undirected-graph.java](./leetcode-java/323-number-of-connected-components-in-an-undirected-graph.java)

    Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.

- [144-binary-tree-preorder-traversal.java](./leetcode-java/144-binary-tree-preorder-traversal.java)

    Given a binary tree, return the preorder traversal of its nodes' values.

- [094-binary-tree-inorder-traversal.java](./leetcode-java/094-binary-tree-inorder-traversal.java)

    Given a binary tree, return the inorder traversal of its nodes' values.

- [156-binary-tree-upside-down.java](./leetcode-java/156-binary-tree-upside-down.java)

    Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

- [230-kth-smallest-element-in-a-bst.java](./leetcode-java/230-kth-smallest-element-in-a-bst.java)

    Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

- [337-house-robber-iii.java](./leetcode-java/337-house-robber-iii.java)

    The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police.

- [108-convert-sorted-array-to-binary-search-tree.java](./leetcode-java/108-convert-sorted-array-to-binary-search-tree.java)

    Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

- [096-unique-binary-search-tree.java](./leetcode-java/096-unique-binary-search-tree.java)

    Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

- [250-count-univalue-subtrees.java](./leetcode-java/250-count-univalue-subtrees.java)

    Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value.

- [298-binary-tree-longest-consecutive-sequence.js](./leetcode-js/298-binary-tree-longest-consecutive-sequence.js)

    Given a binary tree, find the length of the longest consecutive sequence path.

- [255-verify-preorder-sequence-in-binary-search-tree.java](./leetcode-java/255-verify-preorder-sequence-in-binary-search-tree.java)

    Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree. You may assume each number in the sequence is unique.

- [116-populating-next-right-pointers-in-each-node.java](./leetcode-java/116-populating-next-right-pointers-in-each-node.java)

    Given a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

    - You may only use constant extra space.
    - You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

- [222-count-complete-tree-nodes.java](./leetcode-java/222-count-complete-tree-nodes.java)

    Given a complete binary tree, count the number of nodes.

## Array & Hashmap

- [325-maximum-size-subarray-sum-equals-k.js](./leetcode-js/325-maximum-size-subarray-sum-equals-k.js)

    Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

- [220-contains-duplicate-iii.js](./leetcode-js/220-contains-duplicate-iii.js)

    Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.

- [162-find-peak-element.js](./leetcode-js/162-find-peak-element.js)

    A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

- [280-wiggle-sort.java](./leetcode-java/280-wiggle-sort.java)

    Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3].... For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].

- [370-range-addition.java](./leetcode-java/370-range-addition.java)

    Assume you have an array of length n initialized with all 0's and are given k update operations. Each operation is represented as a triplet: `[startIndex, endIndex, inc]` which increments each element of subarray `A[startIndex ... endIndex]` `(startIndex and endIndex inclusive)` with `inc`. Return the modified array after all `k` operations were executed.

- [167-two-sum-ii-input-array-is-sorted.java](./leetcode-java/167-two-sum-ii-input-array-is-sorted.java)

    Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution.

- [245-shortest-word-distance-iii.java](./leetcode-java/245-shortest-word-distance-iii.java)

    Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list.

- [238-product-of-array-except-self.java](./leetcode-java/238-product-of-array-except-self.java)

    Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

- [347-top-k-frequent-elements.java](./leetcode-java/347-top-k-frequent-elements.java)

    Given a non-empty array of integers, return the k most frequent elements.

- [268-missing-number.js](./leetcode-js/268-missing-number.js)

    Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

- [015-3sum.java](./leetcode-java/015-3sum.java)

    Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

- [259-3sum-smaller.java](./leetcode-java/259-3sum-smaller.java)

    Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.

- [216-combination-sum-iii.java](./leetcode-java/216-combination-sum-iii.java)

    Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

- [035-search-insert-position.java](./leetcode-java/035-search-insert-position.java)

    Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

## Linked List

- [369-plus-one-linked-list.java](./leetcode-java/369-plus-one-linked-list.java)

    Given a non-negative number represented as a singly linked list of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list.

- [364-nested-list-weight-sum-ii.java](./leetcode-java/364-nested-list-weight-sum-ii.java)

    Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list -- whose elements may also be integers or other lists. The weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.

- [328-odd-even-linked-list.java](./leetcode-java/328-odd-even-linked-list.java)

    Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

## Matrix

- [311-sparse-matrix-multiplication.java](./leetcode-java/311-sparse-matrix-multiplication.java)

    Given two sparse matrices A and B, return the result of AB. You may assume that A's column number is equal to B's row number.

- [286-walls-and-gates.js](./leetcode-js/286-walls-and-gates.js)

    You are given a m x n 2D grid initialized with these three possible values.

    - -1 - A wall or an obstacle.
    - 0 - A gate.
    - INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.

    Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

## Math

- [343-integer-break.java](./leetcode-java/343-integer-break.java)

    Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

- [319-bulb-switcher.java](./leetcode-java/319-bulb-switcher.java)

    There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.

- [012-integer-to-roman.java](./leetcode-java/012-integer-to-roman.java)

    Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

## Bitwise

- [136-single-number.js](./leetcode-js/136-single-number.js)

    Given an array of integers, every element appears twice except for one. Find that single one.

- [260-single-number-iii.js](./leetcode-js/260-single-number-iii.js)

    Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

- [137-single-number-ii.java](./leetcode-java/137-single-number-ii.java)

    Given an array of integers, every element appears three times except for one. Find that single one.

---

- [281-zigzag-iterator.js](./leetcode-js/281-zigzag-iterator.js)


- [294-flip-game-ii.js](./leetcode-js/294-flip-game-ii.js)

    You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win.

- [320-generalized-abbreviation.java](./leetcode-java/320-generalized-abbreviation.java)

    Write a function to generate the generalized abbreviations of a word. E.g. Given word = "word", return the following list (order does not matter): `["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]`

- [241-different-ways-to-add-parentheses.java](./leetcode-java/241-different-ways-to-add-parentheses.java)

    Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.

- [351-android-unlock-patterns.js](./leetcode-js/351-android-unlock-patterns.js)
- [089-gray-code.js](./leetcode-js/089-gray-code.js)
- [046-permutations.js](./leetcode-js/046-permutations.js)
- [062-unique-paths.js](./leetcode-js/062-unique-paths.js)
- [053-maximum-subarray.js](./leetcode-js/053-maximum-subarray.js)
- [153-find-mim-in-rotated-array.js](./leetcode-js/153-find-mim-in-rotated-array.js)
- [254-factor-combination.js](./leetcode-js/254-factor-combination.js)
- [199-binary-tree-right-side-view.js](./leetcode-js/199-binary-tree-right-side-view.js)
- [367-valid-perfect-square.js](./leetcode-js/367-valid-perfect-square.js)
- [173-binary-search-tree-iterator.js](./leetcode-js/173-binary-search-tree-iterator.js)
- [059-spiral-matrix-ii.js](./leetcode-js/059-spiral-matrix-ii.js)
- [285-inorder-successor-in-bst.js](./leetcode-js/285-inorder-successor-in-bst.js)
- [253-meeting-rooms-ii.js](./leetcode-js/253-meeting-rooms-ii.js)
- [240-search-a-2d-matrix-ii.js](./leetcode-js/240-search-a-2d-matrix-ii.js)
- [077-combinations.js](./leetcode-js/077-combinations.js)
- [064-minimum-path-sum.js](./leetcode-js/064-minimum-path-sum.js)
- [313-super-ugly-number.js](./leetcode-js/313-super-ugly-number.js)
- [334-increasing-triplet-subsequence.js](./leetcode-js/334-increasing-triplet-subsequence.js)
- [300-longest-increasing-subsequence.js](./leetcode-js/300-longest-increasing-subsequence.js)
- [247-strobogrammatic-number-ii.js](./leetcode-js/247-strobogrammatic-number-ii.js)
- [048-rotate-image.js](./leetcode-js/048-rotate-image.js)
- [251-flatten-2d-vector.js](./leetcode-js/251-flatten-2d-vector.js)
- [075-sort-colors.js](./leetcode-js/075-sort-colors.js)
- [289-game-of-life.js](./leetcode-js/289-game-of-life.js)
- [011-container-with-most-water.js](./leetcode-js/011-container-with-most-water.js)
- [277-find-the-celebrity.js](./leetcode-js/277-find-the-celebrity.js)
- [361-bomb-enemy.js](./leetcode-js/361-bomb-enemy.js)
- [244-shortest-word-distance-ii.js](./leetcode-js/244-shortest-word-distance-ii.js)
- [215-kth-largest-element-in-an-array.js](./leetcode-js/215-kth-largest-element-in-an-array.js)
- [074-search-matrix.js](./leetcode-js/074-search-matrix.js)
- [073-set-matrix-zeroes.js](./leetcode-js/073-set-matrix-zeroes.js)
- [279-perfect-squares.js](./leetcode-js/279-perfect-squares.js)
- [279-perfect-squares_math.js](./leetcode-js/279-perfect-squares_math.js)
- [129-sum-root-to-leaf-numbers.js](./leetcode-js/129-sum-root-to-leaf-numbers.js)
- [080-remove-duplicate-from-sorted-array-ii.js](./leetcode-js/080-remove-duplicate-from-sorted-array-ii.js)
- [078-subsets.js](./leetcode-js/078-subsets.js)
- [331-verify-preorder-serialization-of-a-binary-tree.js](./leetcode-js/331-verify-preorder-serialization-of-a-binary-tree.js)
- [341-flatten-nested-list-iterator.js](./leetcode-js/341-flatten-nested-list-iterator.js)
- [275-h-index-ii.js](./leetcode-js/275-h-index-ii.js)
- [039-combination-sum.js](./leetcode-js/039-combination-sum.js)
- [314-binary-tree-vertical-order-traversal.js](./leetcode-js/314-binary-tree-vertical-order-traversal.js)
- [081-search-in-rotated-sorted-array-ii.js](./leetcode-js/081-search-in-rotated-sorted-array-ii.js)
- [114-flatten-binary-tree-to-linked-list.js](./leetcode-js/114-flatten-binary-tree-to-linked-list.js)
- [201-bitwise-and-of-numbers-range.js](./leetcode-js/201-bitwise-and-of-numbers-range.js)
- [090-subsets-ii.js](./leetcode-js/090-subsets-ii.js)
- [213-house-robber-ii.js](./leetcode-js/213-house-robber-ii.js)
- [109-convert-sorted-list-to-binary-search-tree.js](./leetcode-js/109-convert-sorted-list-to-binary-search-tree.js)
- [142-linked-list-cycle-ii.js](./leetcode-js/142-linked-list-cycle-ii.js)
- [120-triangle.js](./leetcode-js/120-triangle.js)
- [368-largest-divisible-subset.js](./leetcode-js/368-largest-divisible-subset.js)
- [274-h-index.js](./leetcode-js/274-h-index.js)
- [147-insertion-sort-list.js](./leetcode-js/147-insertion-sort-list.js)
- [086-partition-list.js](./leetcode-js/086-partition-list.js)
- [163-missing-ranges.js](./leetcode-js/163-missing-ranges.js)
- [017-letter-combinations-of-a-phone-number.js](./leetcode-js/017-letter-combinations-of-a-phone-number.js)
- [063-unique-paths-ii.js](./leetcode-js/063-unique-paths-ii.js)
- [103-binary-tree-zigzag-level-order-traversal.js](./leetcode-js/103-binary-tree-zigzag-level-order-traversal.js)
- [106-convert-binary-tree-from-inorder-and-postorder-traversal.js](./leetcode-js/106-convert-binary-tree-from-inorder-and-postorder-traversal.js)
- [034-search-for-a-range.js](./leetcode-js/034-search-for-a-range.js)
- [264-ugly-number-ii.js](./leetcode-js/264-ugly-number-ii.js)
- [016-3sum-closest.js](./leetcode-js/016-3sum-closest.js)
- [105-construct-binary-tree-from-preorder-and-inorder-traversal.js](./leetcode-js/105-construct-binary-tree-from-preorder-and-inorder-traversal.js)
- [095-unique-binary-search-trees-ii.js](./leetcode-js/095-unique-binary-search-trees-ii.js)
- [113-path-sum-ii.js](./leetcode-js/113-path-sum-ii.js)
- [200-number-of-islands.js](./leetcode-js/200-number-of-islands.js)
- [267-palindrome-permutation-ii.js](./leetcode-js/267-palindrome-permutation-ii.js)
- [161-one-edit-distance.js](./leetcode-js/161-one-edit-distance.js)
- [049-group-anagrams.js](./leetcode-js/049-group-anagrams.js)
- [047-permutations-ii.js](./leetcode-js/047-permutations-ii.js)
- [186-reverse-words-in-a-string-ii.js](./leetcode-js/186-reverse-words-in-a-string-ii.js)
- [040-combination-sum-ii.js](./leetcode-js/040-combination-sum-ii.js)
- [236-lowest-common-ancestor-of-a-binary-tree.js](./leetcode-js/236-lowest-common-ancestor-of-a-binary-tree.js)
- [055-jump-game.js](./leetcode-js/055-jump-game.js)
- [131-palindrome-partitioning.js](./leetcode-js/131-palindrome-partitioning.js)
- [092-reverse-linked-list-ii.js](./leetcode-js/092-reverse-linked-list-ii.js)
- [207-course-schedule.js](./leetcode-js/207-course-schedule.js)
- [356-line-reflection.js](./leetcode-js/356-line-reflection.js)
- [134-gas-station.js](./leetcode-js/134-gas-station.js)
- [333-largest-bst-subtree.js](./leetcode-js/333-largest-bst-subtree.js)
- [209-minimum-size-subarray-sum.js](./leetcode-js/209-minimum-size-subarray-sum.js)
- [082-remove-duplicates-from-sorted-list-ii.js](./leetcode-js/082-remove-duplicates-from-sorted-list-ii.js)
- [310-minimum-height-trees.js](./leetcode-js/310-minimum-height-trees.js)
- [050-pow-x-n.js](./leetcode-js/050-pow-x-n.js)
- [271-encode-and-decode-strings.js](./leetcode-js/271-encode-and-decode-strings.js)
- [031-next-permutation.js](./leetcode-js/031-next-permutation.js)
- [187-repeated-dna-sequences.js](./leetcode-js/187-repeated-dna-sequences.js)
- [229-majority-element-ii.js](./leetcode-js/229-majority-element-ii.js)
- [306-additive-number.js](./leetcode-js/306-additive-number.js)
- [227-basic-calculator-ii.js](./leetcode-js/227-basic-calculator-ii.js)
- [139-word-break.js](./leetcode-js/139-word-break.js)
- [332-reconstruct-itinerary.js](./leetcode-js/332-reconstruct-itinerary.js)
- [069-sqrt-x.js](./leetcode-js/069-sqrt-x.js)
- [060-permutation-sequence.js](./leetcode-js/060-permutation-sequence.js)
- [148-sort-list.js](./leetcode-js/148-sort-list.js)
- [228-summary-ranges.js](./leetcode-js/228-summary-ranges.js)
- [322-coin-change.js](./leetcode-js/322-coin-change.js)
- [208-implement-trie.js](./leetcode-js/208-implement-trie.js)
- [133-clone-graph.js](./leetcode-js/133-clone-graph.js)
- [133-clone-graph_recursive.js](./leetcode-js/133-clone-graph_recursive.js)
- [221-maximum-square.js](./leetcode-js/221-maximum-square.js)
- [018-4sum.js](./leetcode-js/018-4sum.js)
- [150-evaluate-reverse-polish-notation.js](./leetcode-js/150-evaluate-reverse-polish-notation.js)
- [043-multiply-strings.js](./leetcode-js/043-multiply-strings.js)
- [002-add-two-numbers.js](./leetcode-js/002-add-two-numbers.js)
- [093-restore-ip-addresses.js](./leetcode-js/093-restore-ip-addresses.js)
- [079-word-search.js](./leetcode-js/079-word-search.js)
- [324-wiggle-sort-ii.js](./leetcode-js/324-wiggle-sort-ii.js)
- [335-self-crossing.js](./leetcode-js/335-self-crossing.js)
- [005-longest-palindromic-substring.js](./leetcode-js/005-longest-palindromic-substring.js)
- [143-reorder-list.js](./leetcode-js/143-reorder-list.js)
- [061-rotate-list.js](./leetcode-js/061-rotate-list.js)
- [054-spiral-matrix.js](./leetcode-js/054-spiral-matrix.js)
- [365-water-and-jug-problem.js](./leetcode-js/365-water-and-jug-problem.js)
- [152-maximum-product-subarray.js](./leetcode-js/152-maximum-product-subarray.js)
- [003-longest-substring-without-repeating-characters.js](./leetcode-js/003-longest-substring-without-repeating-characters.js)
- [071-simplify-path.js](./leetcode-js/071-simplify-path.js)
- [304-range-sum-query-2d-immutable.js](./leetcode-js/304-range-sum-query-2d-immutable.js)
- [210-course-schedule-ii.js](./leetcode-js/210-course-schedule-ii.js)
- [098-validate-binary-search-tree.js](./leetcode-js/098-validate-binary-search-tree.js)
- [179-largest-number.js](./leetcode-js/179-largest-number.js)
- [127-word-ladder.js](./leetcode-js/127-word-ladder.js)
- [091-decode-ways.js](./leetcode-js/091-decode-ways.js)
- [130-surrounded-regions.js](./leetcode-js/130-surrounded-regions.js)
- [166-fraction-to-recurring-decimal.js](./leetcode-js/166-fraction-to-recurring-decimal.js)
- [029-divide-two-integers.js](./leetcode-js/029-divide-two-integers.js)
- [151-reverse-words-in-a-string.js](./leetcode-js/151-reverse-words-in-a-string.js)
- [348](.348)
- [362](.362)
- [382](.382)
- [384](.384)
- [360](.360)
- [318](.318)
- [377](.377)
- [378](.378)
- [376](.376)
- [284](.284)
- [372](.372)
- [375](.375)
- [373](.373)
- [385](.385)
- [379](.379)
- [355](.355)
- [211](.211)
- [307](.307)

